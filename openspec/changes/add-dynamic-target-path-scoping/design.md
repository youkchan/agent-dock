## コンテキスト
`target_paths=*` は柔軟だが広すぎる。全域探索が頻発すると、タイムアウトや不要な変更候補増加につながる。
ただし実装中に新しい依存ファイルが見つかることは現実的に多く、最初に固定した範囲だけでは不足する。

## 目標
- `*` を許容しつつ、実効作業範囲は自動で絞る。
- 実行途中の発見に追従してスコープを更新できる。
- 更新は監査可能で、再開時にも再現可能にする。
- すべての対象を `TARGET_PROJECT_DIR` 配下に制限する。

## 非目標
- IDE/言語サーバー連携による完全な依存解析
- `TARGET_PROJECT_DIR` 外への自動拡張
- 人手レビューなしの無制限拡張

## 決定事項
### 1) 二層スコープ
- `target_paths` は宣言スコープ（入力設定）。
- `effective_target_paths` は実効スコープ（実行時に更新される）。
- `target_paths=*` の場合、初期は全体許可だが実効スコープを初期スキャンで生成する。

### 2) 初期スキャン
- タスクを `in_progress` にする直前に、タイトル/説明/既知依存を使って候補ファイルを抽出する。
- 候補が空なら安全側で最小セット（関連ディレクトリ）を採用し、`*` のまま全域探索し続けない。

### 3) 実行中拡張
- Teammate は「必要ファイルが実効スコープ外」の時に拡張要求を送れる。
- Lead は要求を評価して `effective_target_paths` を更新する。
- 拡張時は `reason` と追加パスを必須にする。

### 4) 境界制約
- すべてのパスは `TARGET_PROJECT_DIR` 基準で正規化し、外部参照（`..` 含む）は拒否する。

### 5) 監査ログ
- `scope_change_log` を state に持ち、`timestamp`, `task_id`, `actor`, `action`, `paths`, `reason` を保存する。
- resume 時は既存ログを保持し、後続更新を追記する。

## リスクと緩和
- リスク: 初期スキャン誤判定で必要ファイルが漏れる
  - 緩和: 実行中拡張フローを必須化し、ブロックせず修正可能にする
- リスク: 拡張要求が多すぎる
  - 緩和: 1回で複数パスを申請可能にし、同一要求の重複を抑制する
- リスク: セキュリティ境界逸脱
  - 緩和: `TARGET_PROJECT_DIR` 外パスを常時拒否する
